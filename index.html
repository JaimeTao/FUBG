<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç»åœ°æ±‚è€• FUBG - æ‘‡æ†ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤æ‰‹åŠ¿ */
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            width: 100%; 
            max-width: 360px; /* é€‚é…å¤§å¤šæ•°æ‰‹æœºç«–å± */
            height: auto;
            aspect-ratio: 9/16;
            background: #3e2723; /* æ³¥åœŸè‰²èƒŒæ™¯åº•è‰² */
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
            border: 1px solid #444;
        }
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 8px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 14px;
            font-weight: bold;
            z-index: 5;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            text-shadow: 1px 1px 1px black;
        }
        
        /* --- æ‘‡æ†æ§ä»¶æ ·å¼ --- */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px; /* æ§åˆ¶åŒºé«˜åº¦ */
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°ä¸‹é¢çš„å…ƒç´ ï¼Œä½†æ‘‡æ†æœ¬èº«å¼€å¯ç‚¹å‡» */
            z-index: 20;
        }

        /* æ‘‡æ†åº•åº§ */
        #joystick-base {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto; /* å…è®¸è§¦æ‘¸ */
            touch-action: none;
        }
        
        /* æ‘‡æ†å¤´ */
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: linear-gradient(to bottom, #FFD700, #FFA500);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            transition: transform 0.1s; /* å›æ­£åŠ¨ç”» */
        }

        /* æ”»å‡»æŒ‰é’®åŒº */
        .action-area {
            position: absolute;
            bottom: 40px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        .atk-btn {
            width: 80px; height: 80px;
            border-radius: 50%;
            background: rgba(255, 69, 0, 0.6);
            border: 4px solid rgba(255, 69, 0, 0.8);
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; font-weight: bold; 
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .atk-btn:active { background: rgba(255, 69, 0, 0.9); transform: scale(0.95); }

        .upgrade-info {
            padding: 6px 12px; 
            background: rgba(0,0,0,0.6); 
            color: #FFD700;
            border: 1px solid #FFD700;
            border-radius: 5px; 
            font-weight: bold; 
            font-size: 12px;
            text-align: center;
            pointer-events: none;
        }

        #buff-timer {
            position:absolute; top:50px; left:50%; transform:translateX(-50%);
            color:#e040fb; font-weight:bold; display:none; 
            text-shadow:2px 2px 0px #000; font-size: 18px;
            z-index: 10;
        }

        #loading-screen, #game-over {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px; text-align: center;
            border-radius: 12px; border: 2px solid #FFD700;
            z-index: 50; width: 80%; box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #game-over { display: none; }
        button {
            padding: 10px 20px; font-size:16px; 
            background:#FFD700; border:none; border-radius:5px; font-weight:bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="360" height="640"></canvas>
        
        <div id="ui-layer">
            <div class="stat-box">ğŸ’° <span id="goldDisplay">0</span></div>
            <div class="stat-box">ğŸ  <span id="hpDisplay">20</span></div>
            <div class="stat-box">âš”ï¸ <span id="lvlDisplay">1</span></div>
        </div>
        
        <div id="buff-timer">âš¡ ç©¿é€: <span id="buffTimeVal">30</span>s</div>

        <div id="mobile-controls">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>

            <div class="action-area">
                <div id="upgradeInfo" class="upgrade-info">ä¸‹çº§: $100</div>
                <div class="atk-btn" ontouchstart="setKey('Space', true)" ontouchend="setKey('Space', false)">æ”»å‡»</div>
            </div>
        </div>

        <div id="loading-screen">
            <h2 style="color:#FFD700; margin-top:0;">ç»åœ°æ±‚è€• FUBG</h2>
            <p style="color:#ccc;">åŠ è½½èµ„æºä¸­...</p>
        </div>

        <div id="game-over">
            <h2 style="color: #ff5555; margin-top:0;">æ‘åº„å¤±å®ˆ!</h2>
            <p>å¾—åˆ†: <span id="finalScore">0</span></p>
            <button onclick="location.reload()">å†å®ˆä¸€æ¬¡</button>
        </div>
    </div>

<script>
    // --- 0. èµ„æºåŠ è½½ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const loadingScreen = document.getElementById('loading-screen');

    let imagesLoaded = 0;
    const totalImages = 10; 

    function checkAllImagesLoaded() {
        imagesLoaded++;
        if (imagesLoaded === totalImages) {
            loadingScreen.style.display = 'none';
            initGame();
        }
    }

    function loadImg(src) {
        const img = new Image();
        img.onload = checkAllImagesLoaded;
        img.onerror = function() { console.log("ä½¿ç”¨é»˜è®¤æ–¹å—ä»£æ›¿: " + src); checkAllImagesLoaded(); }; // å®¹é”™å¤„ç†
        img.src = src;
        return img;
    }

    // å›¾ç‰‡åˆ—è¡¨
    const bgImg = loadImg('BG.png');
    const baseImg = loadImg('base.png');
    const base2Img = loadImg('base2.png');
    const playerImg = loadImg('player1.png');
    const enemyImg = loadImg('enemy1.png');
    const coinImg = loadImg('coin.png');
    const bulletImg = loadImg('bullet1.png');
    const juma1Img = loadImg('juma1.png');
    const juma2Img = loadImg('juma2.png');
    const powerupImg = loadImg('powerup.png');

    // --- 1. æ¸¸æˆå‚æ•° ---
    const TILE_SIZE = 40; 
    const COLS = 9;  
    const ROWS = 16; 
    
    // --- 2. æ‘‡æ†é€»è¾‘ ---
    const joystickBase = document.getElementById('joystick-base');
    const joystickKnob = document.getElementById('joystick-knob');
    let joystickData = { active: false, x: 0, y: 0, dir: null };

    joystickBase.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystickData.active = true;
        joystickKnob.style.transition = 'none'; // ç§»é™¤è¿‡æ¸¡ï¼Œå®æ—¶è·Ÿéš
        updateJoystick(e.touches[0]);
    }, {passive: false});

    joystickBase.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if(joystickData.active) updateJoystick(e.touches[0]);
    }, {passive: false});

    joystickBase.addEventListener('touchend', (e) => {
        e.preventDefault();
        joystickData.active = false;
        joystickData.dir = null;
        // å›æ­£
        joystickKnob.style.transition = 'transform 0.1s';
        joystickKnob.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
    });

    function updateJoystick(touch) {
        const rect = joystickBase.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // è®¡ç®—åç§»é‡
        let dx = touch.clientX - centerX;
        let dy = touch.clientY - centerY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        const maxRadius = rect.width / 2; // é™åˆ¶åœ¨åœˆå†…

        // é™åˆ¶æ‘‡æ†å¤´ç§»åŠ¨èŒƒå›´
        if (distance > maxRadius) {
            const ratio = maxRadius / distance;
            dx *= ratio;
            dy *= ratio;
        }

        // ç§»åŠ¨æ‘‡æ†å¤´
        joystickKnob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;

        // è®¡ç®—æ–¹å‘ (ç®€åŒ–ä¸º4æ–¹å‘)
        if (Math.abs(dx) > Math.abs(dy)) {
            // å·¦å³
            if (Math.abs(dx) > 20) { // æ­»åŒº 20px
                joystickData.dir = dx > 0 ? 'right' : 'left';
            } else {
                joystickData.dir = null;
            }
        } else {
            // ä¸Šä¸‹
            if (Math.abs(dy) > 20) {
                joystickData.dir = dy > 0 ? 'down' : 'up';
            } else {
                joystickData.dir = null;
            }
        }
    }


    // --- 3. æ¸¸æˆçŠ¶æ€ ---
    let gameState = {
        gold: 0, baseHp: 20, level: 1, score: 0, isGameOver: false,
        upgradeCost: 100, upgradeTimer: 0,
        map: [] 
    };

    const keys = {};
    window.setKey = function(code, status) { keys[code] = status; };

    // åŸºåœ°ä½ç½® (ä¿æŒä¸å˜)
    const base = { x: 120, y: 520, width: 120, height: 120, scale: 1.0 };

    // ç©å®¶é…ç½® (ä¿®æ”¹ç‚¹ï¼šä½ç½®å‰ç§»ï¼Œä½“ç§¯å˜å¤§)
    let player = {
        col: 4, row: 9, // ä¿®æ”¹ï¼šä»12æ”¹ä¸º9ï¼Œåˆå§‹ä½ç½®æ›´é å‰ (çº¦ Y=360)
        x: 160, y: 360,
        targetX: 160, targetY: 360,
        // ç¢°æ’ç®±ç»´æŒ 32ï¼Œä½†ç»˜åˆ¶å°ºå¯¸ä¼šæ”¾å¤§
        width: 32, height: 32, 
        drawSize: 48, // ä¿®æ”¹ï¼šç»˜åˆ¶å°ºå¯¸æ”¾å¤§
        speed: 4, 
        direction: 'up', 
        isMoving: false,
        cooldown: 0, maxCooldown: 20,
        piercing: false, piercingTimer: 0
    };
    
    let bullets = [];
    let enemies = [];
    let coins = [];
    let particles = [];
    let items = [];
    let obstacles = [];

    // --- 4. åˆå§‹åŒ– ---
    function initGame() {
        generateMap();
        loop();
        updateUI();
    }

    function generateMap() {
        obstacles = [];
        // ä¿æŠ¤åœˆ
        const protectRing = [
            {c:2, r:12}, {c:3, r:12}, {c:4, r:12}, {c:5, r:12}, {c:6, r:12}, 
            {c:2, r:13}, {c:6, r:13}, {c:2, r:14}, {c:6, r:14}, {c:2, r:15}, {c:6, r:15}
        ];
        protectRing.forEach(p => addObstacle(p.c, p.r, 2));

        // éšæœºéšœç¢ (å¢åŠ ç”ŸæˆèŒƒå›´)
        for (let r = 2; r < 11; r++) {
            for (let c = 0; c < COLS; c++) {
                // ä¸åœ¨ç©å®¶åˆå§‹ç‚¹ç”Ÿæˆ
                if (c === 4 && r === 9) continue;
                if (Math.random() < 0.12) { 
                    addObstacle(c, r, Math.random() < 0.5 ? 1 : 2);
                }
            }
        }
    }

    function addObstacle(c, r, type) {
        if (obstacles.some(o => o.col === c && o.row === r)) return;
        obstacles.push({
            col: c, row: r, x: c * TILE_SIZE, y: r * TILE_SIZE,
            width: TILE_SIZE, height: TILE_SIZE, type: type, hp: 3, flashTimer: 0
        });
    }

    function isWalkable(c, r) {
        if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return false;
        if (obstacles.some(o => o.col === c && o.row === r)) return false;
        if (c >= 3 && c <= 5 && r >= 13) return false; // åŸºåœ°ä¸­å¿ƒä¸å¯å…¥
        return true;
    }

    // é”®ç›˜ç›‘å¬ (ä¿ç•™ä½œä¸ºå¤‡ç”¨)
    window.addEventListener('keydown', e => {
        if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) e.preventDefault();
        keys[e.code] = true;
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    // --- 5. æ ¸å¿ƒå¾ªç¯ ---
    function update() {
        if (gameState.isGameOver) return;

        // ç©å®¶ç§»åŠ¨ (ç»“åˆé”®ç›˜ å’Œ æ‘‡æ†)
        if (!player.isMoving) {
            let nextCol = player.col;
            let nextRow = player.row;
            let inputDir = joystickData.dir; // è·å–æ‘‡æ†æ–¹å‘

            // é”®ç›˜ä¼˜å…ˆçº§å…¼å®¹
            if (keys['ArrowUp'] || keys['KeyW']) inputDir = 'up';
            if (keys['ArrowDown'] || keys['KeyS']) inputDir = 'down';
            if (keys['ArrowLeft'] || keys['KeyA']) inputDir = 'left';
            if (keys['ArrowRight'] || keys['KeyD']) inputDir = 'right';

            if (inputDir === 'up') { player.direction = 'up'; nextRow--; }
            else if (inputDir === 'down') { player.direction = 'down'; nextRow++; }
            else if (inputDir === 'left') { player.direction = 'left'; nextCol--; }
            else if (inputDir === 'right') { player.direction = 'right'; nextCol++; }

            if ((nextCol !== player.col || nextRow !== player.row) && isWalkable(nextCol, nextRow)) {
                player.isMoving = true;
                player.col = nextCol;
                player.row = nextRow;
                // è®¡ç®—åƒç´ åæ ‡ (å±…ä¸­)
                player.targetX = nextCol * TILE_SIZE + (TILE_SIZE - player.width)/2;
                player.targetY = nextRow * TILE_SIZE + (TILE_SIZE - player.height)/2;
            }
        } else {
            // å¹³æ»‘ç§»åŠ¨
            const moveStep = player.speed;
            if (player.x < player.targetX) player.x = Math.min(player.x + moveStep, player.targetX);
            if (player.x > player.targetX) player.x = Math.max(player.x - moveStep, player.targetX);
            if (player.y < player.targetY) player.y = Math.min(player.y + moveStep, player.targetY);
            if (player.y > player.targetY) player.y = Math.max(player.y - moveStep, player.targetY);

            if (Math.abs(player.x - player.targetX) < 1 && Math.abs(player.y - player.targetY) < 1) {
                player.x = player.targetX;
                player.y = player.targetY;
                player.isMoving = false;
            }
        }

        // ç©å®¶å°„å‡»
        if (player.cooldown > 0) player.cooldown--;
        if (keys['Space'] && player.cooldown <= 0) {
            fireBullet(player);
            player.cooldown = player.maxCooldown;
        }

        // Buff è®¡æ—¶
        if (player.piercing) {
            player.piercingTimer--;
            if (player.piercingTimer % 60 === 0) document.getElementById('buffTimeVal').innerText = Math.ceil(player.piercingTimer / 60);
            if (player.piercingTimer <= 0) {
                player.piercing = false;
                document.getElementById('buff-timer').style.display = 'none';
            }
        }

        // åŸºåœ°åŠ¨ç”»
        if (base.scale > 1.0) base.scale -= 0.02;

        // è‡ªåŠ¨å‡çº§
        if (gameState.gold >= gameState.upgradeCost) {
            gameState.upgradeTimer++;
            if (gameState.upgradeTimer > 60) performUpgrade();
        } else gameState.upgradeTimer = 0;

        updateBullets();
        updateEnemies();
        updateCoins();
        updateItems();
        updateParticles();
        
        // æ‹’é©¬é—ªçƒ
        for (let i = obstacles.length - 1; i >= 0; i--) {
            if (obstacles[i].flashTimer > 0) obstacles[i].flashTimer--;
            if (obstacles[i].hp <= 0) {
                createExplosion(obstacles[i].x + 20, obstacles[i].y + 20, '#aaa', 5);
                obstacles.splice(i, 1);
            }
        }

        const spawnRate = 0.005 + (gameState.level * 0.0005);
        if (Math.random() < spawnRate && enemies.length < 5) spawnEnemy();
    }

    function fireBullet(shooter) {
        const bSpeed = 6 + (shooter === player ? gameState.level : 0);
        let vx=0, vy=0, angle=0, w=12, h=30;
        if (shooter.direction === 'up') { vy = -bSpeed; angle = 0; }
        else if (shooter.direction === 'down') { vy = bSpeed; angle = Math.PI; }
        else if (shooter.direction === 'left') { vx = -bSpeed; angle = -Math.PI/2; w=30; h=12;}
        else if (shooter.direction === 'right') { vx = bSpeed; angle = Math.PI/2; w=30; h=12;}

        bullets.push({
            x: shooter.x + shooter.width/2, y: shooter.y + shooter.height/2,
            width: w, height: h, visualW: 14, visualH: 34, // å­å¼¹ä¹Ÿç¨å¾®ç”»å¤§ä¸€ç‚¹
            angle: angle, vx: vx, vy: vy,
            owner: shooter === player ? 'player' : 'enemy',
            isPiercing: (shooter === player && player.piercing)
        });
    }

    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx; b.y += b.vy;
            if (b.x < -20 || b.x > 380 || b.y < -20 || b.y > 660) { bullets.splice(i, 1); continue; }

            let hitbox = {x: b.x - b.width/2, y: b.y - b.height/2, width: b.width, height: b.height};
            let hit = false;

            if (!b.isPiercing) {
                for (let k = 0; k < obstacles.length; k++) {
                    let obs = obstacles[k];
                    if (rectIntersect(hitbox, obs)) {
                        obs.hp--; obs.flashTimer = 5; 
                        bullets.splice(i, 1); hit = true;
                        createExplosion(b.x, b.y, '#fff', 2); break; 
                    }
                }
            }
            if (hit) continue;

            if (b.owner === 'player') {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (rectIntersect(hitbox, e)) {
                        e.hp--;
                        if (!b.isPiercing) bullets.splice(i, 1);
                        hit = true;
                        createExplosion(b.x, b.y, '#FFD700', 3);
                        if (e.hp <= 0) { enemyDie(e); enemies.splice(j, 1); }
                        break; 
                    }
                }
            } else {
                if (rectIntersect(hitbox, player)) {
                    bullets.splice(i, 1); createExplosion(player.x+20, player.y+20, '#FFF', 5);
                } else if (rectIntersect(hitbox, base)) {
                    damageBase(); bullets.splice(i, 1);
                }
            }
            if(hit && !b.isPiercing) continue;
        }
    }

    function enemyDie(e) {
        createExplosion(e.x + 20, e.y + 20, '#FF4500', 10);
        coins.push({
            x: e.x + 10, y: e.y + 10, size: 20, value: 10 + gameState.level * 5, // é‡‘å¸ç¨å¾®å˜å¤§
            vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4
        });
        if (Math.random() < 0.2) {
            items.push({
                x: e.x + 8, y: e.y + 8, width: 32, height: 32, // é“å…·å˜å¤§
                type: 'piercing', life: 600 
            });
        }
        gameState.score += 10;
        updateUI();
    }

    function updateEnemies() {
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (!e.isMoving) {
                if (Math.random() < 0.1) {
                    let nextCol = e.col, nextRow = e.row;
                    let dir = '';
                    // ç®€å•çš„å¯»è·¯é€»è¾‘
                    if (e.row < 13) { 
                         if (Math.random() < 0.7) { nextRow++; dir='down'; }
                         else {
                             if (e.col < 4) { nextCol++; dir='right'; }
                             else if (e.col > 4) { nextCol--; dir='left'; }
                             else { nextRow++; dir='down'; }
                         }
                    } else {
                        if (e.col < 4) { nextCol++; dir='right'; }
                        else if (e.col > 4) { nextCol--; dir='left'; }
                    }
                    if (isWalkable(nextCol, nextRow) && dir !== '') {
                        e.isMoving = true; e.direction = dir; e.col = nextCol; e.row = nextRow;
                        e.targetX = nextCol * TILE_SIZE + (TILE_SIZE-e.width)/2;
                        e.targetY = nextRow * TILE_SIZE + (TILE_SIZE-e.height)/2;
                    }
                }
            } else {
                let spd = 1.5;
                if (e.x < e.targetX) e.x = Math.min(e.x+spd, e.targetX);
                if (e.x > e.targetX) e.x = Math.max(e.x-spd, e.targetX);
                if (e.y < e.targetY) e.y = Math.min(e.y+spd, e.targetY);
                if (e.y > e.targetY) e.y = Math.max(e.y-spd, e.targetY);
                if (Math.abs(e.x - e.targetX) < 1 && Math.abs(e.y - e.targetY) < 1) {
                    e.x = e.targetX; e.y = e.targetY; e.isMoving = false;
                }
            }
            if (Math.random() < 0.01) fireBullet(e);
        }
    }

    function updateCoins() {
        const baseCX = base.x + base.width/2;
        const baseCY = base.y + base.height/2;
        for (let i = coins.length - 1; i >= 0; i--) {
            let c = coins[i];
            c.x += c.vx; c.y += c.vy; c.vx *= 0.9; c.vy *= 0.9; 
            let dx = baseCX - (c.x + c.size/2); let dy = baseCY - (c.y + c.size/2);
            let dist = Math.sqrt(dx*dx + dy*dy);
            c.x += dx * 0.08; c.y += dy * 0.08;
            if (dist < 40) {
                gameState.gold += c.value; coins.splice(i, 1); updateUI();
                base.scale = 1.15; 
            }
        }
    }

    function updateItems() {
        for (let i = items.length - 1; i >= 0; i--) {
            let it = items[i]; it.life--;
            if (it.life <= 0) { items.splice(i, 1); continue; }
            let pRect = {x:player.x, y:player.y, width:player.width, height:player.height};
            if (rectIntersect(it, pRect)) {
                if (it.type === 'piercing') {
                    player.piercing = true; player.piercingTimer = 30 * 60;
                    document.getElementById('buff-timer').style.display = 'block';
                    createExplosion(player.x, player.y, '#e040fb', 20);
                }
                items.splice(i, 1);
            }
        }
    }

    function spawnEnemy() {
        let c = Math.floor(Math.random() * COLS); let r = 0;
        if (!isWalkable(c, r)) return;
        enemies.push({
            col: c, row: r,
            x: c * TILE_SIZE + 4, y: r * TILE_SIZE + 4,
            targetX: c * TILE_SIZE + 4, targetY: r * TILE_SIZE + 4,
            width: 32, height: 32, 
            drawSize: 48, // ä¿®æ”¹ï¼šç»˜åˆ¶å°ºå¯¸æ”¾å¤§
            hp: 2 + Math.floor(gameState.level/2),
            direction: 'down', isMoving: false
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

        // ç»˜åˆ¶åŸºåœ°
        const bImg = gameState.level > 1 ? base2Img : baseImg;
        let bw = base.width * base.scale; let bh = base.height * base.scale;
        let bx = base.x - (bw - base.width)/2; let by = base.y - (bh - base.height)/2;
        if (gameState.gold >= gameState.upgradeCost && Math.floor(Date.now()/200)%2===0) ctx.globalAlpha = 0.7;
        ctx.drawImage(bImg, bx, by, bw, bh);
        ctx.globalAlpha = 1.0;

        obstacles.forEach(o => {
            let img = o.type === 1 ? juma1Img : juma2Img;
            ctx.save();
            if (o.flashTimer > 0) ctx.filter = 'brightness(200%)';
            ctx.drawImage(img, o.x, o.y, o.width, o.height);
            ctx.restore();
        });

        items.forEach(it => {
            let dy = Math.sin(Date.now()/200)*3;
            // é“å…·å°ºå¯¸
            ctx.drawImage(powerupImg, it.x, it.y + dy, it.width, it.height);
        });

        coins.forEach(c => ctx.drawImage(coinImg, c.x, c.y, c.size, c.size));

        // ç»˜åˆ¶æ•Œäºº (ä¿®æ”¹ï¼šä½¿ç”¨ drawSize æ”¾å¤§è§†è§‰ï¼Œä½†ä¸­å¿ƒå¯¹é½)
        enemies.forEach(e => {
            let offset = (e.drawSize - e.width) / 2;
            ctx.drawImage(enemyImg, e.x - offset, e.y - offset, e.drawSize, e.drawSize);
            ctx.fillStyle = 'red'; ctx.fillRect(e.x, e.y-8, e.width, 3);
            ctx.fillStyle = '#0f0'; ctx.fillRect(e.x, e.y-8, (e.hp/ (2+Math.floor(gameState.level/2)))*e.width, 3);
        });

        // ç»˜åˆ¶ç©å®¶ (ä¿®æ”¹ï¼šä½¿ç”¨ drawSize æ”¾å¤§è§†è§‰)
        ctx.save();
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        let ang = 0;
        if(player.direction==='right') ang=Math.PI/2;
        if(player.direction==='down') ang=Math.PI;
        if(player.direction==='left') ang=-Math.PI/2;
        ctx.rotate(ang);
        if (player.piercing) ctx.filter = 'hue-rotate(180deg) drop-shadow(0 0 5px #e040fb)';
        if (player.piercing && player.piercingTimer < 180 && Math.floor(Date.now()/100)%2===0) ctx.filter = 'none';
        
        // ç»˜åˆ¶ (æ³¨æ„è´Ÿåæ ‡åç§»)
        ctx.drawImage(playerImg, -player.drawSize/2, -player.drawSize/2, player.drawSize, player.drawSize);
        ctx.restore();

        bullets.forEach(b => {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.angle);
            if (b.isPiercing) ctx.filter = 'hue-rotate(180deg) brightness(150%)';
            ctx.drawImage(bulletImg, -b.visualW/2, -b.visualH/2, b.visualW, b.visualH);
            ctx.restore();
        });

        particles.forEach(p => {
            ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 20;
            ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1;
        });
    }

    function rectIntersect(r1, r2) {
        // ç¢°æ’æ£€æµ‹ç¨å¾®ç¼©å°ä¸€ç‚¹èŒƒå›´ï¼Œé¿å…â€œæ˜æ˜æ²¡ç¢°åˆ°å´æ­»äº†â€
        let padding = 4;
        return !(r2.x + padding > r1.x + r1.width - padding || 
                 r2.x + r2.width - padding < r1.x + padding || 
                 r2.y + padding > r1.y + r1.height - padding || 
                 r2.y + r2.height - padding < r1.y + padding);
    }

    function createExplosion(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
                life: 20, size: 2+Math.random()*2, color: color
            });
        }
    }
    
    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i]; p.life--; p.x += p.vx; p.y += p.vy;
            if(p.life<=0) particles.splice(i,1);
        }
    }

    function performUpgrade() {
        gameState.gold -= gameState.upgradeCost;
        gameState.level++; gameState.baseHp += 5;
        gameState.upgradeCost = Math.floor(gameState.upgradeCost * 1.5);
        updateUI();
        createExplosion(base.x+60, base.y+60, '#FFD700', 50);
    }

    function damageBase() {
        gameState.baseHp--; updateUI(); base.scale = 0.9;
        if(gameState.baseHp<=0) {
            gameState.isGameOver = true;
            document.getElementById('game-over').style.display='block';
        }
    }

    function updateUI() {
        document.getElementById('goldDisplay').innerText = gameState.gold;
        document.getElementById('hpDisplay').innerText = gameState.baseHp;
        document.getElementById('lvlDisplay').innerText = gameState.level;
        document.getElementById('finalScore').innerText = gameState.score;
        const info = document.getElementById('upgradeInfo');
        info.innerText = `ä¸‹çº§è´¹ç”¨: $${gameState.upgradeCost}`;
        if (gameState.gold >= gameState.upgradeCost) {
            info.style.backgroundColor = '#FFD700'; info.style.color = '#000';
        } else {
            info.style.backgroundColor = 'rgba(0,0,0,0.5)'; info.style.color = '#FFD700';
        }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

</script>
</body>
</html>
