<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç»åœ°æ±‚è€• - é“å…·è¿›é˜¶ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: white;
            font-family: "SimHei", "Microsoft YaHei", sans-serif;
            overflow: hidden;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.9);
            width: 100%;
            max-width: 450px;
            height: auto;
            aspect-ratio: 9/16;
            background: #333;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .hud-text {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            padding: 10px;
        }
        #hp-display { top: 0; left: 0; color: #ff5555; }
        #gold-display { top: 0; right: 0; color: #FFD700; }

        /* Buff æç¤ºæ–‡å­— */
        #buff-indicator {
            position: absolute;
            top: 50px; left: 10px;
            color: #e040fb;
            font-weight: bold;
            display: none;
            text-shadow: 1px 1px 2px black;
        }

        /* å‰§æƒ…å¼€åœº */
        #intro-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: black;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50; pointer-events: auto; padding: 40px; box-sizing: border-box;
        }
        .intro-line {
            color: #ddd; font-size: 20px; line-height: 2; text-align: center;
            opacity: 0; transform: translateY(20px); transition: opacity 1s, transform 1s;
            margin-bottom: 10px;
        }
        .intro-line.visible { opacity: 1; transform: translateY(0); }
        #start-btn {
            margin-top: 40px; opacity: 0; transition: opacity 1s; pointer-events: none;
            padding: 15px 40px; font-size: 20px; background: #d4a017;
            color: #3e2723; border: 2px solid #fff; border-radius: 8px; font-weight: bold;
        }
        #start-btn.visible { opacity: 1; pointer-events: auto; }

        /* æ¸¸æˆç»“æŸ */
        #game-over-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); flex-direction: column; align-items: center; justify-content: center;
            z-index: 40; pointer-events: auto;
        }
        .restart-btn {
            padding: 15px 40px; font-size: 20px; background: #d4a017;
            color: #3e2723; border: 2px solid #fff; border-radius: 8px; font-weight: bold; cursor: pointer;
        }

        /* æ§åˆ¶å™¨ */
        #controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 160px;
            pointer-events: none; z-index: 10;
        }
        .d-pad {
            position: absolute; bottom: 20px; left: 20px;
            width: 140px; height: 140px; pointer-events: auto;
        }
        .d-btn {
            position: absolute; width: 45px; height: 45px;
            background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px; display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: rgba(255,255,255,0.8); user-select: none;
        }
        .d-btn:active { background: rgba(255, 215, 0, 0.4); }
        .btn-up { top: 0; left: 47px; } .btn-down { bottom: 0; left: 47px; }
        .btn-left { top: 47px; left: 0; } .btn-right { top: 47px; right: 0; }

        .atk-btn-container {
            position: absolute; bottom: 40px; right: 30px; width: 85px; height: 85px; pointer-events: auto;
        }
        .atk-btn {
            width: 100%; height: 100%; border-radius: 50%;
            background: rgba(255, 69, 0, 0.6); border: 4px solid rgba(255, 69, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 20px; color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5); user-select: none;
        }
        .atk-btn:active { transform: scale(0.92); background: rgba(255, 69, 0, 0.9); }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="360" height="640"></canvas>
    
    <div id="ui-layer">
        <div id="hp-display" class="hud-text">â¤ï¸ ç”Ÿå‘½: 10</div>
        <div id="gold-display" class="hud-text">ğŸ’° ç²®é£Ÿ: 0</div>
        <div id="buff-indicator">âš¡ ç©¿é€æ”»å‡»ç”Ÿæ•ˆä¸­</div>
    </div>

    <div id="intro-screen">
        <div class="intro-line">ä¸œæ±‰æœ«å¹´æ”¿æƒåŠ¨è¡ï¼Œ</div>
        <div class="intro-line">å…µåŒªå››èµ·ï¼Œæ°‘ç”Ÿå‡‹æ•ã€‚</div>
        <div class="intro-line" style="margin-top: 20px; color: #FFD700;">å¸®åŠ©è€å†œå®ˆå«å†œç”°ï¼Œ</div>
        <div class="intro-line" style="color: #FFD700;">ä¸è¦è®©å£«ç ´åè‰¯ç”°ã€‚</div>
        <button id="start-btn" onclick="startGame()">ç»åœ°æ±‚è€•</button>
    </div>

    <div id="game-over-screen">
        <h2 style="color: #ff5555; margin-bottom: 10px; font-size: 30px;">å†œç”°å¤±å®ˆ</h2>
        <p style="color: #ddd; margin-bottom: 30px; font-size: 20px;">æœ€ç»ˆæ”¶é›†: <span id="final-score">0</span></p>
        <button class="restart-btn" onclick="location.reload()">é‡æ–°æ¥è¿‡</button>
    </div>

    <div id="controls">
        <div class="d-pad">
            <div class="d-btn btn-up" ontouchstart="setInput('up', true)" ontouchend="setInput('up', false)">â¬†ï¸</div>
            <div class="d-btn btn-down" ontouchstart="setInput('down', true)" ontouchend="setInput('down', false)">â¬‡ï¸</div>
            <div class="d-btn btn-left" ontouchstart="setInput('left', true)" ontouchend="setInput('left', false)">â¬…ï¸</div>
            <div class="d-btn btn-right" ontouchstart="setInput('right', true)" ontouchend="setInput('right', false)">â¡ï¸</div>
        </div>
        <div class="atk-btn-container">
            <div class="atk-btn" ontouchstart="setInput('attack', true)" ontouchend="setInput('attack', false)">æ”»å‡»</div>
        </div>
    </div>
</div>

<script>
    // --- å‰§æƒ…åŠ¨ç”» ---
    window.onload = function() {
        const lines = document.querySelectorAll('.intro-line');
        const btn = document.getElementById('start-btn');
        let delay = 500;
        lines.forEach((line) => {
            setTimeout(() => { line.classList.add('visible'); }, delay);
            delay += 1500;
        });
        setTimeout(() => { btn.classList.add('visible'); }, delay);
        preloadAssets();
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- èµ„æºåŠ è½½ ---
    const assets = {};
    let loadedCount = 0;
    const imageList = [
        'BG.png', 'famer_idle.png', 'enemy1.png', 'bullet1.png', 'scythe.png',
        'base.png', 'base2.png', 'straw.png', 'wheat01.png', 'juma.png', 'coin.png',
        'powerup.png', 'gold_scythe.png', // å¢åŠ  powerup
        'famer_attack.001.png', 'famer_attack.002.png', 'famer_attack.003.png',
        'famer_attack.004.png', 'famer_attack.005.png', 'famer_attack.006.png'
    ];

    function preloadAssets() {
        imageList.forEach(name => {
            const img = new Image();
            img.src = name;
            img.onload = () => { assets[name] = img; loadedCount++; };
            img.onerror = () => { loadedCount++; };
        });
    }

    // --- å¸¸é‡ ---
    const GRID_SIZE = 40;
    const COLS = 9; const ROWS = 16; 
    
    // --- è¾“å…¥ ---
    const input = { up: false, down: false, left: false, right: false, attack: false };
    window.setInput = (key, val) => { 
        input[key] = val; 
        if(key === 'attack' && val === true && player && !player.isAttacking) triggerAttack();
    };
    window.addEventListener('keydown', e => {
        if(e.repeat) return;
        switch(e.code) {
            case 'ArrowUp': case 'KeyW': setInput('up', true); break;
            case 'ArrowDown': case 'KeyS': setInput('down', true); break;
            case 'ArrowLeft': case 'KeyA': setInput('left', true); break;
            case 'ArrowRight': case 'KeyD': setInput('right', true); break;
            case 'Space': setInput('attack', true); break;
        }
    });
    window.addEventListener('keyup', e => {
        switch(e.code) {
            case 'ArrowUp': case 'KeyW': setInput('up', false); break;
            case 'ArrowDown': case 'KeyS': setInput('down', false); break;
            case 'ArrowLeft': case 'KeyA': setInput('left', false); break;
            case 'ArrowRight': case 'KeyD': setInput('right', false); break;
            case 'Space': setInput('attack', false); break;
        }
    });

    // --- æ¸¸æˆçŠ¶æ€ ---
    let gameState = { running: false, score: 0, gameOver: false, baseLevel: 1, upgradeThreshold: 100 };

    // --- å®ä½“ç±» ---
    class Entity {
        constructor(col, row, width, height) {
            this.col = col; this.row = row;
            this.x = col * GRID_SIZE; this.y = row * GRID_SIZE;
            this.width = width; this.height = height;
            this.markedForDeletion = false;
        }
    }

    class Player extends Entity {
        constructor() {
            super(4, 10, GRID_SIZE, GRID_SIZE);
            this.hp = 10;
            this.direction = 0; 
            this.isMoving = false;
            this.moveSpeed = 4;
            this.targetX = this.x; this.targetY = this.y;
            this.isAttacking = false;
            this.attackFrame = 0; this.attackTimer = 0;
            this.hasPiercing = false; this.piercingTimer = 0;
        }
        update() {
            if (this.hasPiercing) {
                this.piercingTimer--;
                document.getElementById('buff-indicator').style.display = 'block';
                if (this.piercingTimer <= 0) {
                    this.hasPiercing = false;
                    document.getElementById('buff-indicator').style.display = 'none';
                }
            }
            if (this.isAttacking) {
                this.attackTimer++;
                if (this.attackTimer % 5 === 0) { 
                    this.attackFrame++;
                    if (this.attackFrame === 4) spawnScythe();
                    if (this.attackFrame > 6) { this.isAttacking = false; this.attackFrame = 0; }
                }
                return;
            }
            if (this.isMoving) {
                if (this.x < this.targetX) this.x += this.moveSpeed;
                if (this.x > this.targetX) this.x -= this.moveSpeed;
                if (this.y < this.targetY) this.y += this.moveSpeed;
                if (this.y > this.targetY) this.y -= this.moveSpeed;
                if (Math.abs(this.x - this.targetX) < this.moveSpeed && Math.abs(this.y - this.targetY) < this.moveSpeed) {
                    this.x = this.targetX; this.y = this.targetY;
                    this.col = Math.round(this.x / GRID_SIZE);
                    this.row = Math.round(this.y / GRID_SIZE);
                    this.isMoving = false;
                }
            } else {
                let dCol = 0, dRow = 0;
                if (input.up) { dRow = -1; this.direction = 0; }
                else if (input.down) { dRow = 1; this.direction = 2; }
                else if (input.left) { dCol = -1; this.direction = 3; }
                else if (input.right) { dCol = 1; this.direction = 1; }
                if (dCol !== 0 || dRow !== 0) {
                    let nextC = this.col + dCol; let nextR = this.row + dRow;
                    if (canWalk(nextC, nextR)) {
                        this.isMoving = true;
                        this.targetX = nextC * GRID_SIZE; this.targetY = nextR * GRID_SIZE;
                    }
                }
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x + GRID_SIZE/2, this.y + GRID_SIZE/2);
            ctx.rotate(this.direction * Math.PI / 2);
            let img;
            if (this.isAttacking) {
                let frameIndex = Math.min(this.attackFrame, 6);
                if (frameIndex < 1) frameIndex = 1;
                let padIndex = String(frameIndex).padStart(3, '0');
                img = assets[`famer_attack.${padIndex}.png`];
            } else {
                img = assets['famer_idle.png'];
            }
            if (img) ctx.drawImage(img, -GRID_SIZE/2, -GRID_SIZE/2, GRID_SIZE, GRID_SIZE);
            else { ctx.fillStyle = 'blue'; ctx.fillRect(-GRID_SIZE/2, -GRID_SIZE/2, GRID_SIZE, GRID_SIZE); }
            ctx.restore();
        }
    }

    class Enemy extends Entity {
        constructor() {
            let c = Math.floor(Math.random() * COLS);
            super(c, -1, GRID_SIZE, GRID_SIZE);
            this.speed = 0.5 + Math.random() * 0.5;
            this.shootTimer = Math.random() * 200;
        }
        update() {
            this.y += this.speed;
            this.row = Math.floor(this.y / GRID_SIZE);
            this.shootTimer--;
            if (this.shootTimer <= 0) {
                spawnBullet(this.x + GRID_SIZE/2, this.y + GRID_SIZE);
                this.shootTimer = 150 + Math.random() * 100;
            }
            if (this.row >= 13 && this.col >= 3 && this.col <= 5) gameOver();
            if (this.y > canvas.height) this.markedForDeletion = true;
        }
        draw() {
            let img = assets['enemy1.png'];
            if (img) ctx.drawImage(img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
    }

    class Projectile extends Entity {
        constructor(x, y, dx, dy, type, isPiercing = false) {
            super(0, 0, 30, 30);
            this.x = x; this.y = y; this.dx = dx; this.dy = dy;
            this.type = type; this.angle = 0; this.isPiercing = isPiercing;
        }
        update() {
            this.x += this.dx; this.y += this.dy;
            if (this.type === 'scythe') this.angle += 0.3;
            else this.angle = Math.PI; 
            if (this.x < -50 || this.x > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) this.markedForDeletion = true;
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            let imgName = this.type === 'scythe' ? (this.isPiercing ? 'gold_scythe.png' : 'scythe.png') : 'bullet1.png';
            let img = assets[imgName];
            if (!img && this.isPiercing) img = assets['scythe.png'];

            // ä¿®å¤ç®­çŸ¢æ¯”ä¾‹: 12å®½, 30é«˜
            if (this.type === 'arrow') {
                if(img) ctx.drawImage(img, -6, -15, 12, 30);
                else { ctx.fillStyle = 'white'; ctx.fillRect(-3, -10, 6, 20); }
            } else {
                if(img) ctx.drawImage(img, -15, -15, 30, 30);
                else { ctx.fillStyle = 'gold'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); }
            }
            ctx.restore();
        }
    }

    class PowerUp extends Entity {
        constructor(x, y) {
            super(0, 0, 30, 30);
            this.x = x; this.y = y;
            this.timer = 0;
            this.offsetY = 0;
        }
        update() {
            this.timer += 0.1;
            this.offsetY = Math.sin(this.timer) * 5; // ä¸Šä¸‹æµ®åŠ¨
        }
        draw() {
            let img = assets['powerup.png'];
            let drawY = this.y + this.offsetY;
            if(img) ctx.drawImage(img, this.x - 15, drawY - 15, 30, 30);
            else { ctx.fillStyle = '#e040fb'; ctx.beginPath(); ctx.arc(this.x, drawY, 10, 0, Math.PI*2); ctx.fill(); }
            
            ctx.font = '10px "SimHei"';
            ctx.fillStyle = '#ff00ff';
            ctx.textAlign = 'center';
            ctx.fillText("ç©¿é€æ”»å‡»", this.x, drawY + 25);
        }
    }

    class Obstacle extends Entity {
        constructor(col, row, type, widthTiles = 1, heightTiles = 1) {
            super(col, row, GRID_SIZE * widthTiles, GRID_SIZE * heightTiles);
            this.type = type; 
            this.widthTiles = widthTiles;
            this.heightTiles = heightTiles;
            this.hp = 3;
            if (type === 'juma' || type === 'base') this.hp = 999; 
        }
        hit() {
            if (this.type === 'straw') {
                this.hp--;
                if (this.hp <= 0) this.markedForDeletion = true;
            }
        }
        draw() {
            let imgName = '';
            if (this.type === 'straw') imgName = 'straw.png';
            else if (this.type === 'juma') imgName = 'juma.png';
            else if (this.type === 'base') imgName = gameState.baseLevel === 1 ? 'base.png' : 'base2.png';

            let img = assets[imgName];
            if (img) ctx.drawImage(img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = 'brown'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
    }

    class Coin extends Entity {
        constructor(x, y) {
            super(0, 0, 20, 20);
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 5; this.vy = (Math.random() - 0.5) * 5;
            this.state = 'drop'; this.timer = 0;
        }
        update() {
            if (this.state === 'drop') {
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.9; this.vy *= 0.9;
                this.timer++;
                if (this.timer > 30) this.state = 'fly';
            } else {
                // é£å‘æ–°çš„å¤§ä»“åº“ä¸­å¿ƒ (å³ä¸‹è§’å æ®3x3)
                // Base is at COLS-3, ROWS-3. Center is:
                let tx = (COLS - 3 + 1.5) * GRID_SIZE;
                let ty = (ROWS - 3 + 1.5) * GRID_SIZE;
                let dx = tx - this.x; let dy = ty - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                this.x += (dx / dist) * 12; this.y += (dy / dist) * 12;
                if (dist < 20) { collectCoin(); this.markedForDeletion = true; }
            }
        }
        draw() {
            let img = assets['coin.png'];
            if(img) ctx.drawImage(img, this.x - 10, this.y - 10, 20, 20);
            else { ctx.fillStyle = 'gold'; ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill(); }
        }
    }

    // --- å…¨å±€ ---
    let player;
    let enemies = [];
    let projectiles = [];
    let obstacles = [];
    let coins = [];
    let items = [];
    let baseEffects = { scale: 1, brightness: 100 };

    function initLevel() {
        player = new Player();
        enemies = []; projectiles = []; obstacles = []; coins = []; items = [];
        gameState.score = 0; gameState.baseLevel = 1;
        document.getElementById('hp-display').innerText = "â¤ï¸ ç”Ÿå‘½: 10";
        document.getElementById('gold-display').innerText = "ğŸ’° ç²®é£Ÿ: 0";

        // å†œç”°ä¿æŠ¤åœˆ (Row 12-15)
        obstacles.push(new Obstacle(3, 12, 'juma'));
        obstacles.push(new Obstacle(4, 12, 'juma'));
        obstacles.push(new Obstacle(5, 12, 'juma'));
        for(let r=13; r<=15; r++) {
            obstacles.push(new Obstacle(2, r, 'juma'));
            obstacles.push(new Obstacle(6, r, 'juma'));
        }
        
        // ä»“åº“å·¨å¤§åŒ– (3x3), ä½ç½®åœ¨å³ä¸‹è§’ (COLS-3, ROWS-3)
        obstacles.push(new Obstacle(COLS-3, ROWS-3, 'base', 3, 3));

        // éšæœºè‰å †
        for (let r = 2; r < 10; r++) {
            for (let c = 0; c < COLS; c++) {
                if(c===4 && r===10) continue;
                if (Math.random() < 0.15) obstacles.push(new Obstacle(c, r, 'straw'));
            }
        }
    }

    function spawnScythe() {
        let dx = 0, dy = 0; let speed = 8;
        if (player.direction === 0) dy = -speed;
        if (player.direction === 1) dx = speed;
        if (player.direction === 2) dy = speed;
        if (player.direction === 3) dx = -speed;
        projectiles.push(new Projectile(player.x+GRID_SIZE/2, player.y+GRID_SIZE/2, dx, dy, 'scythe', player.hasPiercing));
    }
    function spawnBullet(x, y) {
        projectiles.push(new Projectile(x, y, 0, 4, 'arrow'));
    }
    function triggerAttack() {
        if (!player.isAttacking) { player.isAttacking = true; player.attackFrame = 0; player.attackTimer = 0; }
    }
    
    // ç¢°æ’æ£€æŸ¥éœ€è¦è€ƒè™‘ç‰©ä½“çš„å®½åº¦å’Œé«˜åº¦ï¼ˆå› ä¸ºä»“åº“å˜å¤§äº†ï¼‰
    function canWalk(col, row) {
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return false;
        for (let o of obstacles) {
            // æ£€æŸ¥è¯¥ç‚¹æ˜¯å¦åœ¨éšœç¢ç‰©çš„æ ¼å­èŒƒå›´å†…
            if (col >= o.col && col < o.col + o.widthTiles &&
                row >= o.row && row < o.row + o.heightTiles) {
                return false;
            }
        }
        return true;
    }

    function checkCollisions() {
        // 1. ç©å®¶æ‹¾å–é“å…·
        let pRect = { x: player.x, y: player.y, w: GRID_SIZE, h: GRID_SIZE };
        items.forEach(it => {
            let itRect = { x: it.x - 15, y: it.y - 15, w: 30, h: 30 };
            if (isColliding(pRect, itRect)) {
                it.markedForDeletion = true;
                player.hasPiercing = true;
                player.piercingTimer = 600; // 10ç§’
            }
        });
        items = items.filter(i => !i.markedForDeletion);

        // 2. æŠ•å°„ç‰©
        projectiles.forEach(p => {
            if (p.markedForDeletion) return;
            let rect1 = { x: p.x - 10, y: p.y - 10, w: 20, h: 20 };
            
            if (p.type === 'scythe') {
                // é•°åˆ€ vs æ•Œäºº
                enemies.forEach(e => {
                    if (isColliding(rect1, e)) {
                        e.markedForDeletion = true;
                        // ä¿®æ”¹ï¼šå¦‚æœç©¿é€ï¼Œä¸é”€æ¯é•°åˆ€
                        if (!p.isPiercing) p.markedForDeletion = true;
                        
                        // æ‰è½é€»è¾‘
                        if (Math.random() < 0.05) { // 5% æ‰é“å…·
                            items.push(new PowerUp(e.x + GRID_SIZE/2, e.y + GRID_SIZE/2));
                        } else {
                            coins.push(new Coin(e.x + GRID_SIZE/2, e.y + GRID_SIZE/2));
                        }
                    }
                });
                
                // é•°åˆ€ vs é˜»æŒ¡ç‰© (ä»…è‰å †)
                obstacles.forEach(o => {
                    if (o.type === 'straw' && isColliding(rect1, o)) {
                        // ä¿®æ”¹ï¼šå¦‚æœç©¿é€ï¼Œä¸é€ æˆä¼¤å®³ä¹Ÿä¸é”€æ¯
                        if (!p.isPiercing) {
                            o.hit();
                            p.markedForDeletion = true;
                        }
                    }
                });
            } else {
                // ç®­çŸ¢ logic
                let pRect = { x: player.x, y: player.y, w: GRID_SIZE, h: GRID_SIZE };
                if (isColliding(rect1, pRect)) {
                    p.markedForDeletion = true;
                    player.hp--;
                    document.getElementById('hp-display').innerText = "â¤ï¸ ç”Ÿå‘½: " + player.hp;
                    if (player.hp <= 0) gameOver();
                }
                obstacles.forEach(o => {
                    if (isColliding(rect1, o)) p.markedForDeletion = true;
                });
            }
        });
    }

    function isColliding(rect1, rect2) {
        let r2x = rect2.x; let r2w = rect2.width || rect2.w;
        let r2y = rect2.y; let r2h = rect2.height || rect2.h;
        return (rect1.x < r2x + r2w && rect1.x + rect1.w > r2x &&
                rect1.y < r2y + r2h && rect1.y + rect1.h > r2y);
    }

    function collectCoin() {
        gameState.score += 10;
        document.getElementById('gold-display').innerText = "ğŸ’° ç²®é£Ÿ: " + gameState.score;
        baseEffects.scale = 1.1; 
        baseEffects.brightness = 150;
        if (gameState.score >= gameState.upgradeThreshold && gameState.baseLevel === 1) {
            gameState.baseLevel = 2; gameState.upgradeThreshold *= 2; 
        }
    }

    function gameOver() {
        gameState.running = false; gameState.gameOver = true;
        document.getElementById('final-score').innerText = gameState.score;
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function loop() {
        if (!gameState.running) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // èƒŒæ™¯
        if (assets['BG.png']) ctx.drawImage(assets['BG.png'], 0, 0, canvas.width, canvas.height);
        else { ctx.fillStyle = '#4e342e'; ctx.fillRect(0,0,canvas.width, canvas.height); }

        // å†œç”°
        for(let r=13; r<ROWS; r++){
            for(let c=3; c<=5; c++){
                let img = assets['wheat01.png'];
                if(img) ctx.drawImage(img, c*GRID_SIZE, r*GRID_SIZE, GRID_SIZE, GRID_SIZE);
            }
        }

        // å®ä½“æ›´æ–°
        obstacles = obstacles.filter(o => !o.markedForDeletion);
        obstacles.forEach(o => o.draw());

        items.forEach(i => { i.update(); i.draw(); });

        if (Math.random() < 0.005) enemies.push(new Enemy());
        enemies = enemies.filter(e => !e.markedForDeletion);
        enemies.forEach(e => { e.update(); e.draw(); });

        player.update();
        player.draw();

        projectiles = projectiles.filter(p => !p.markedForDeletion);
        projectiles.forEach(p => { p.update(); p.draw(); });

        coins = coins.filter(c => !c.markedForDeletion);
        coins.forEach(c => { c.update(); c.draw(); });

        checkCollisions();

        // ä»“åº“ç‰¹æ•ˆ
        if (baseEffects.scale > 1) baseEffects.scale -= 0.01;
        if (baseEffects.brightness > 100) baseEffects.brightness -= 2;
        
        let baseObj = obstacles.find(o => o.type === 'base');
        if (baseObj) {
            ctx.save();
            // ä»“åº“ä¸­å¿ƒç‚¹: baseObj.x + (3*40)/2 = baseObj.x + 60
            ctx.translate(baseObj.x + baseObj.width/2, baseObj.y + baseObj.height/2);
            ctx.scale(baseEffects.scale, baseEffects.scale);
            ctx.filter = `brightness(${baseEffects.brightness}%)`;
            let bImgName = gameState.baseLevel === 1 ? 'base.png' : 'base2.png';
            if(assets[bImgName]) ctx.drawImage(assets[bImgName], -baseObj.width/2, -baseObj.height/2, baseObj.width, baseObj.height);
            ctx.restore();
        }

        requestAnimationFrame(loop);
    }

    function startGame() {
        document.getElementById('intro-screen').style.display = 'none';
        initLevel();
        gameState.running = true;
        loop();
    }
</script>
</body>
</html>
